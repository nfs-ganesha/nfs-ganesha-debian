From ac1899fd37a04e9d2ec366a7dd27d579ebc0b318 Mon Sep 17 00:00:00 2001
From: Soumya Koduri <skoduri@redhat.com>
Date: Tue, 18 Oct 2016 00:18:29 +0530
Subject: [PATCH] FSAL_GLUSTER: Use the new APIs to fetch & free upcall args

GlusterFS Upcall handling APIs have been remodelled to do
all the memory handling needed in gfapi and make the upcall
structure opaque so that in case if there are any changes
to it in future, it shall not break existing applications.

http://review.gluster.org/#/c/14701/ (merged into Gluster 3.7.16)
http://review.gluster.org/#/c/15653/ (hopefully will get into 3.7.17)

This change is to consume those APIs in FSAL_GLUSTER.

Change-Id: Iad6c97a09aed801e7abd979cb452076bfef68b62
Signed-off-by: Soumya Koduri <skoduri@redhat.com>
---

diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 2cf5fdf..d329e8b 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -511,7 +511,7 @@
   IF(GLUSTER_PREFIX)
     set(ENV{PKG_CONFIG_PATH} "${PKG_CONFIG_PATH}:${GLUSTER_PREFIX}/lib/pkgconfig")
   ENDIF(GLUSTER_PREFIX)
-  pkg_check_modules(GFAPI glusterfs-api>=7.3.8)
+  pkg_check_modules(GFAPI glusterfs-api)
   if(NOT GFAPI_FOUND)
     if(STRICT_PACKAGE)
       message(FATAL_ERROR "STRICT PACKAGE: Cannot find GLUSTER GFAPI runtime. Disabling GLUSTER fsal build")
diff --git a/src/FSAL/FSAL_GLUSTER/fsal_up.c b/src/FSAL/FSAL_GLUSTER/fsal_up.c
index 070a8f5..e213319 100644
--- a/src/FSAL/FSAL_GLUSTER/fsal_up.c
+++ b/src/FSAL/FSAL_GLUSTER/fsal_up.c
@@ -96,21 +96,23 @@
 	}
 
 out:
-	glfs_h_close(object);
 	return rc;
 }
 
 void *GLUSTERFSAL_UP_Thread(void *Arg)
 {
-	struct glusterfs_export     *glfsexport                 = Arg;
+	struct glusterfs_export     *glfsexport         = Arg;
 	const struct fsal_up_vector *event_func;
 	char                        thr_name[16];
-	int                         rc                          = 0;
-	struct callback_arg         callback;
-	struct callback_inode_arg   *cbk_inode_arg              = NULL;
-	int                         reason                      = 0;
-	int                         retry                       = 0;
-	int                         errsv                       = 0;
+	int                         rc                  = 0;
+	struct glfs_upcall          *cbk                = NULL;
+	struct glfs_upcall_inode    *in_arg             = NULL;
+	enum glfs_upcall_reason     reason              = 0;
+	int                         retry               = 0;
+	int                         errsv               = 0;
+	struct glfs_object          *object             = NULL;
+	struct glfs_object          *p_object           = NULL;
+	struct glfs_object          *oldp_object        = NULL;
 
 
 	snprintf(thr_name, sizeof(thr_name),
@@ -138,8 +140,6 @@
 		goto out;
 	}
 
-	callback.fs = glfsexport->gl_fs;
-
 	/* Start querying for events and processing. */
 	/** @todo : Do batch processing instead */
 	while (!atomic_fetch_int8_t(&glfsexport->destroy_mode)) {
@@ -147,11 +147,10 @@
 			     "Requesting event from FSAL Callback interface for %p.",
 			     glfsexport->gl_fs);
 
-		callback.reason = 0;
+		reason = 0;
 
-		rc = glfs_h_poll_upcall(glfsexport->gl_fs, &callback);
+		rc = glfs_h_poll_upcall(glfsexport->gl_fs, &cbk);
 		errsv = errno;
-		reason = callback.reason;
 
 		if (rc != 0) {
 			/* if ENOMEM retry for couple of times
@@ -190,42 +189,49 @@
 			     "Received upcall event: reason(%d)",
 			     reason);
 
+		if (!cbk) {
+			usleep(10);
+			continue;
+		}
+
+		reason = glfs_upcall_get_reason(cbk);
 		/* Decide what type of event this is
 		 * inode update / invalidate? */
 		switch (reason) {
-		case GFAPI_CBK_EVENT_NULL:
+		case GLFS_UPCALL_EVENT_NULL:
 			usleep(10);
 			continue;
-		case GFAPI_INODE_INVALIDATE:
-			cbk_inode_arg =
-				(struct callback_inode_arg *)callback.event_arg;
+		case GLFS_UPCALL_INODE_INVALIDATE:
+			in_arg = glfs_upcall_get_event(cbk);
 
-			if (!cbk_inode_arg) {
+			if (!in_arg) {
 				/* Could be ENOMEM issues. continue */
 				LogWarn(COMPONENT_FSAL_UP,
 					"Received NULL upcall event arg");
 				break;
 			}
 
-			if (cbk_inode_arg->object)
+			object = glfs_upcall_inode_get_object(in_arg);
+			if (object)
 				upcall_inode_invalidate(glfsexport,
-							cbk_inode_arg->object);
-			if (cbk_inode_arg->p_object)
+							object);
+			p_object = glfs_upcall_inode_get_pobject(in_arg);
+			if (p_object)
 				upcall_inode_invalidate(glfsexport,
-						  cbk_inode_arg->p_object);
-			if (cbk_inode_arg->oldp_object)
+							p_object);
+			oldp_object = glfs_upcall_inode_get_object(in_arg);
+			if (oldp_object)
 				upcall_inode_invalidate(glfsexport,
-						  cbk_inode_arg->oldp_object);
+							oldp_object);
 			break;
 		default:
 			LogWarn(COMPONENT_FSAL_UP, "Unknown event: %d", reason);
 			continue;
 		}
-		if (cbk_inode_arg) {
-			free(cbk_inode_arg);
-			cbk_inode_arg = NULL;
+		if (cbk) {
+			glfs_free(cbk);
+			cbk = NULL;
 		}
-		callback.event_arg = NULL;
 	}
 
 out:
